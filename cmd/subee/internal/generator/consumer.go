package generator

import (
	"bytes"
	"context"
	"fmt"
	"go/types"
	"io/ioutil"
	"os"
	"path/filepath"
	"text/template"

	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

type ConsumerGenerator interface {
	Generate(context.Context, *ConsumerParams) error
}

func NewConsumerGenerator(
	pkgCfg *packages.Config,
) ConsumerGenerator {
	return &consumerGeneratorImpl{
		pkgCfg: pkgCfg,
	}
}

type consumerGeneratorImpl struct {
	pkgCfg *packages.Config
}

func (g *consumerGeneratorImpl) Generate(ctx context.Context, params *ConsumerParams) error {
	if err := params.Validate(); err != nil {
		return errors.WithStack(err)
	}
	if g.pkgCfg.Mode < packages.LoadTypes {
		return errors.Errorf("invalid packages.LoadMode: %v", g.pkgCfg.Mode)
	}

	if params.IsWithAdapter() {
		pkgs, err := packages.Load(g.pkgCfg, params.Package.Path)
		if err != nil {
			return errors.WithStack(err)
		}
		var obj types.Object
		for _, pkg := range pkgs {
			obj = pkg.Types.Scope().Lookup(params.Message)
			if obj == nil {
				continue
			}
			if _, ok := obj.Type().Underlying().(*types.Struct); !ok {
				continue
			}
			break
		}
		params.Package.Path = obj.Pkg().Path()
		params.Package.Name = obj.Pkg().Name()
		if filepath.Base(params.Package.Path) == params.Package.Name {
			params.Imports = append(params.Imports, Package{Path: params.Package.Path})
		} else {
			params.Imports = append(params.Imports, params.Package)
		}
		if params.Encoding == MessageEncodingProtobuf {
			params.Imports = append(params.Imports, Package{Path: "github.com/golang/protobuf/proto"})
		}
	}

	err := g.writeFile(filepath.Join("pkg", "consumer", strcase.ToSnake(params.Name)+"_consumer.go"), params, consumerTmpl)
	if err != nil {
		return errors.WithStack(err)
	}

	if params.IsWithAdapter() {
		err = g.writeFile(filepath.Join("pkg", "consumer", strcase.ToSnake(params.Name)+"_consumer_adapter.go"), params, adapterTmpl)
		if err != nil {
			return errors.WithStack(err)
		}
	}

	err = g.writeFile(filepath.Join("cmd", strcase.ToKebab(params.Name)+"-worker", "run.go"), params, runTmpl)
	if err != nil {
		return errors.WithStack(err)
	}

	err = g.writeFile(filepath.Join("cmd", strcase.ToKebab(params.Name)+"-worker", "main.go"), params, mainTmpl)
	if err != nil {
		return errors.WithStack(err)
	}

	return nil
}

func mustCreateTemplate(name, text string) *template.Template {
	return template.Must(template.New(name).Funcs(tmplFuncs).Parse(text))
}

func (g *consumerGeneratorImpl) writeFile(path string, params interface{}, tmpl *template.Template) error {
	buf := new(bytes.Buffer)
	err := tmpl.Execute(buf, params)
	if err != nil {
		return errors.WithStack(err)
	}
	path = filepath.Join(g.pkgCfg.Dir, path)
	data, err := imports.Process(path, buf.Bytes(), nil)
	if err != nil {
		return errors.WithStack(err)
	}
	if _, err := os.Stat(filepath.Dir(path)); err != nil {
		err = os.MkdirAll(filepath.Dir(path), 0755)
		if err != nil {
			return errors.WithStack(err)
		}
	}
	err = ioutil.WriteFile(path, data, 0644)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

var (
	tmplFuncs = template.FuncMap{
		"ToCamel":      strcase.ToCamel,
		"ToLowerCamel": strcase.ToLowerCamel,
	}

	mainTmpl = mustCreateTemplate("cmd/{{.Name}}/main.go",
		`// Code generated by github.com/wantedly/subee/cmd/subee. DO NOT EDIT.

package main

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}`)

	runTmpl = mustCreateTemplate("cmd/{{.Name}}/run.go",
		`package main

func run() error {
	ctx := context.Background()

	subscriber, err := createSubscriber(ctx)
	if err != nil {
		return errors.WithStack(err)
	}

	engine := subee.NewWithSingleMessageConsumer(
		subscriber,
		{{- if .IsWithAdapter}}
		consumer.New{{.Name|ToCamel}}ConsumerAdapter(
			consumer.New{{.Name|ToCamel}}Consumer(),
		),
		{{- else}}
		consumer.New{{.Name|ToCamel}}Consumer(),
		{{- end}}
	)

	return engine.Start(ctx)
}

func createSubscriber(ctx context.Context) (subee.Subscriber, error) {
	// TODO: not yet implemented
	return nil, errors.New("createSubscriber() has not been implemented yet")
}`)

	consumerTmpl = mustCreateTemplate("pkg/consumer/{{.Name}}_consumer.go",
		`package consumer

import (
{{- range .Imports}}
	{{- if .Name}}
		{{.Name}} "{{.Path}}"
	{{- else}}
		"{{.Path}}"
	{{- end}}
{{- end}}
)

{{- if .IsWithAdapter}}
// {{.Name|ToCamel}}Consumer is a consumer interface for {{.Package.Name}}.{{.Message}}.
type {{.Name|ToCamel}}Consumer interface {
	{{- if .Batch}}
	Consume(context.Context, []*{{.Package.Name}}.{{.Message}}) error
	{{- else}}
	Consume(context.Context, *{{.Package.Name}}.{{.Message}}) error
	{{- end}}
}
{{- else}}
// {{.Name|ToCamel}}Consumer is a consumer interface.
type {{.Name|ToCamel}}Consumer subee.SingleMessageConsumer
{{- end}}

// New{{.Name|ToCamel}}Consumer creates a new consumer instance.
func New{{.Name|ToCamel}}Consumer() {{.Name|ToCamel}}Consumer {
	return &{{.Name|ToLowerCamel}}ConsumerImpl{}
}

type {{.Name|ToLowerCamel}}ConsumerImpl struct {}

{{- if .Batch}}
{{- if .IsWithAdapter}}
func (c *{{.Name|ToLowerCamel}}ConsumerImpl) Consume(ctx context.Context, msgs []*{{.Package.Name}}.{{.Message}}) error {
{{- else}}
func (c *{{.Name|ToLowerCamel}}ConsumerImpl) Consume(ctx context.Context, msgs []subee.Message) error {
{{- end}}
{{- else}}
{{- if .IsWithAdapter}}
func (c *{{.Name|ToLowerCamel}}ConsumerImpl) Consume(ctx context.Context, msg *{{.Package.Name}}.{{.Message}}) error {
{{- else}}
func (c *{{.Name|ToLowerCamel}}ConsumerImpl) Consume(ctx context.Context, msg subee.Message) error {
{{- end}}
{{- end}}
	return errors.New("Consume() has not been implemented yet")
}`)

	adapterTmpl = mustCreateTemplate("pkg/consumer/{{.Name}}_consumer_adapter.go",
		`// Code generated by github.com/wantedly/subee/cmd/subee. DO NOT EDIT.

package consumer

import (
{{- range .Imports}}
	{{- if .Name}}
		{{.Name}} "{{.Path}}"
	{{- else}}
		"{{.Path}}"
	{{- end}}
{{- end}}
)

// New{{.Name|ToCamel}}ConsumerAdapter created a consumer-adapter instance that converts incoming messages into {{.Package.Name}}.{{.Message}}.
func New{{.Name|ToCamel}}ConsumerAdapter(consumer {{.Name|ToCamel}}Consumer) subee.SingleMessageConsumer {
	return &{{.Name|ToLowerCamel}}ConsumerAdapterImpl{consumer: consumer}
}

type {{.Name|ToLowerCamel}}ConsumerAdapterImpl struct {
	consumer {{.Name|ToCamel}}Consumer
}

{{- if .Batch}}
func (a *{{.Name|ToLowerCamel}}ConsumerAdapterImpl) Consume(ctx context.Context, ms []subee.Message) error {
	var err error
	objs := make([]*{{.Package.Name}}.{{.Message}}, len(ms))
	for i, m := range ms {
		obj := new({{.Package.Name}}.{{.Message}})
		{{- if .IsJSON}}
		err = json.Unmarshal(m.Data(), obj)
		{{- else if .IsProtobuf}}
		err = proto.Unmarshal(m.Data(), obj)
		{{- end}}
		if err != nil {
			return errors.WithStack(err)
		}
		objs[i] = obj
	}
	err = a.consumer.Consume(ctx, objs)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}
{{- else}}
func (a *{{.Name|ToLowerCamel}}ConsumerAdapterImpl) Consume(ctx context.Context, m subee.Message) error {
	var err error
	obj := new({{.Package.Name}}.{{.Message}})
	{{- if .IsJSON}}
	err = json.Unmarshal(m.Data(), obj)
	{{- else if .IsProtobuf}}
	err = proto.Unmarshal(m.Data(), obj)
	{{- end}}
	if err != nil {
		return errors.WithStack(err)
	}
	err = a.consumer.Consume(ctx, obj)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}
{{- end}}`)
)

type ConsumerParams struct {
	Package  Package
	Message  string
	Encoding MessageEncoding
	Name     string
	Batch    bool
	Imports  []Package
}

func (p *ConsumerParams) Validate() error {
	switch {
	case p.Package.Path != "" && p.Message == "":
		return fmt.Errorf("message is required")
	case p.Package.Path == "" && p.Message != "":
		return fmt.Errorf("package is required")
	case p.Name == "":
		return fmt.Errorf("name is required")
	}
	return nil
}

func (p *ConsumerParams) IsWithAdapter() bool {
	return p.Package.Path != "" && p.Message != ""
}

func (p *ConsumerParams) IsJSON() bool {
	return p.Encoding == MessageEncodingJSON
}

func (p *ConsumerParams) IsProtobuf() bool {
	return p.Encoding == MessageEncodingProtobuf
}

type MessageEncoding int

const (
	MessageEncodingUnknown MessageEncoding = iota
	MessageEncodingJSON
	MessageEncodingProtobuf
)

var (
	nameByMessageEncoding = map[MessageEncoding]string{}
	messageTypeByName     = map[string]MessageEncoding{}
)

func init() {
	nameByMessageEncoding = map[MessageEncoding]string{
		MessageEncodingJSON:     "json",
		MessageEncodingProtobuf: "protobuf",
	}
	for e, s := range nameByMessageEncoding {
		messageTypeByName[s] = e
	}
}

func (me MessageEncoding) String() string {
	if s, ok := nameByMessageEncoding[me]; ok {
		return s
	}
	return "unknown"
}

func (me *MessageEncoding) Set(in string) error {
	if v, ok := messageTypeByName[in]; ok {
		*me = v
		return nil
	}
	return fmt.Errorf("unknown message type %q", in)
}

func (MessageEncoding) Type() string {
	return "MessageEncoding"
}

type Package struct {
	Name string
	Path string
}
